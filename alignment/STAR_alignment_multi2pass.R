# Author(s): Regina H. Reynolds

#---Load Libraries and data--------------------------------------------------------------------------------------------------------------####
library(tidyverse)
library(stringr)
library(optparse)
library(RNAseqProcessing)

# Main ------------------------------------------------------------------------------------------------

arguments <- parse_args(OptionParser(usage = "%prog",
                                     prog = "STAR: multi-sample 2nd pass mapping",
                                     description="Script for running 2nd pass mapping with STAR. Required inputs:\n <fastq_dir_paths>: Directory paths to fastq separated by ','.\n <genome_index_path>: Path to genome index used by STAR for mapping reads.\n <output_path>: Path to output folder.\n <sj_path>: Path to merged (and potentially filtered) SJ.out.tab from all samples. This should contain the following columns:\n 1. chromosome\n 2. first base of intron (1-based)\n 3. last base of intron (1-based).\n These columns are the same as the first three found in the original SJ.out.tab files. See STAR manual for more details.",
                                     option_list=list(
                                       make_option(c("-p","--sample_prefix"), default = "", help="If the fastq paths have a prefix before the sample name (as is often added by the sequencer), this needs to be given here. E.g. Fastq file name may be NM3330_PDC05_A1A2_GM-T_S4_R1_001_QC.fastq.gz. As sample name is 'PDC05_A1A2_GM-T', will need to provide the argument 'NM3330_' or 'NM...._' if want it to be generalisable to other NM tags. [default: Empty string]"),
                                       make_option(c("-s","--sample_suffix"), default = "", help="The text (or regex) that needs to be excluded from the tail end of the filename to get the sample name. E.g. For M3330_PDC05_A1A2_GM-T_S4_R1_001_QC.fastq.gz, would use argument '_S.*' to remove everything after _S. [default: Empty string]"),
                                       make_option(c("-r","--read_groups"), default = NULL, help="If enabled, this will add the flag --outSAMattrRGline to the STAR command. As an argument, must supply path to a tab-delimited .txt file with a dataframe containing the read group information. This file should, as a minimum, contain the columns:\n 1. full_name = full name of the file without .fastq.gz\n 2. sample_name = same as the name when you remove the sample_prefix and sample_suffix\n 3. PU = Flowcell:Lane:Adapter, which is typically generated by the sequencing provider"))),
                        positional_arguments = 4)


# # Comment in if want to test run script
# arguments <- list()
# arguments$args[1] <- "/data/RNAseq_PD/tissue_polyA_samples/QC/fastp"
# arguments$args[2] <- "/data/STAR_data/genome_index_hg38_ens_v97/sjdbOverhang_99"
# arguments$args[3] <- "/data/RNAseq_PD/tissue_polyA_samples/STAR"
# arguments$args[4] <- "/data/RNAseq_PD/tissue_polyA_samples/STAR/all_samples_non_duplicated_junctions.SJ.out.tab"
# arguments$opt$sample_prefix <- "NM...._"
# arguments$opt$sample_suffix <- "_S.*"
# arguments$opt$read_groups  <- "/home/rreynolds/projects/Aim2_PDsequencing/data/Flowcell_info.txt"

opt <- arguments$opt

# Positional arguments
fastq_dir_paths <- arguments$args[1] %>% str_split(",") %>% unlist()
genome_index_path <- arguments$args[2]
output_path <- arguments$args[3]
sj_path <- arguments$args[4]

# If '-r' flag enabled, read in dataframe with read group information.
if(!is.null(opt$read_groups)){
  cat("Loading read group information from", opt$read_groups, "\n")
  if(file.exists(opt$read_groups)){
    read_groups <- read_delim(file = opt$read_groups, delim = "\t")
  } else warning("File ", opt$read_groups, " does not exist")
} else {
  cat("No read group information provided.\n")
}

# Create fastq dataframe
fastq_df <- RNAseqProcessing::get_fastqc_for_STAR_df(fastq_dir_paths,
                                                     prefix_to_sample_name = opt$sample_prefix,
                                                     to_exclude_to_get_sample_name = opt$sample_suffix)

sample_names_uniq <- fastq_df$sample_name %>% unique()
threads_STAR <- 15

# Determine limitSjdb for the --limitSjdbInsertNsj flag
# Default is 1,000,000 and value should not be vastly bigger than this.
# If total number of junctions (+ a 20% buffer) in file inputted into --sjdbFileChrStartEnd < 10000000, then set to default, otherwise set to total number of junctions in file.
n_junc <- read_delim(file = sj_path, col_names = FALSE, col_types = "cdd", delim = "\t") %>% nrow()
if ((n_junc * 1.2) <= 1000000) {
  limitSjdb <- 1000000
} else{
  limitSjdb <- round(n_junc * 1.2)
}

print(str_c(Sys.time(), " - STAR alignment for samples: ", str_c(sample_names_uniq, collapse = ", ")))

# Loop calling STAR
for(i in seq_along(sample_names_uniq)){

  sample_name_to_filter <- sample_names_uniq[i]

  print(str_c(Sys.time(), " - aligning sample: ", sample_name_to_filter))

  fastq_per_sample_paths_trimmed_paired <-
    fastq_df %>%
    dplyr::filter(sample_name == sample_name_to_filter) %>%
    .[["fastq_paths_trimmed_paired"]]

  # Filter read_groups dataframe for correct sample
  read_group <-
    read_groups %>%
    dplyr::filter(sample_name == sample_name_to_filter)

  if(length(fastq_per_sample_paths_trimmed_paired) != 2) { stop(str_c("number fastq files for ", sample_name_to_filter, " not 2, expected because of paired-end")) }

  if(is.null(opt$read_groups)){

    system(command = str_c("STAR",
                           " --runThreadN ", threads_STAR,
                           " --genomeDir ", genome_index_path,
                           " --sjdbFileChrStartEnd ", sj_path,
                           " --readFilesIn ", fastq_per_sample_paths_trimmed_paired[1], " ", fastq_per_sample_paths_trimmed_paired[2],
                           " --readFilesCommand  zcat ", # because fastq's are zipped
                           "--outFileNamePrefix ",  str_c(output_path, "/", sample_name_to_filter, "_ "),
                           "--outReadsUnmapped Fastx ", # output in separate fast/fastq files the unmapped/partially-mapped reads
                           "--outSAMtype BAM SortedByCoordinate ", # output as a sorted BAM
                           "--outFilterType BySJout ", # removes spurious split reads
                           "--outFilterMultimapNmax 1 ", # only allows reads to be mapped to one position in the genome
                           "--outFilterMismatchNmax 999 ", # Maximum number of mismatches per pair. Large numbers switch off filter. Instead we filter by "--outFilterMismatchNoverReadLmax".
                           "--outFilterMismatchNoverReadLmax 0.04 ", # max number of mismatches per pair relative to read length. As per current ENCODE options.
                           "--alignIntronMin 20 ", # min intron length. As per ENCODE options.
                           "--alignIntronMax 1000000 ", # max intron length. As per ENCODE options (currently from ensembl its 1,097,903 from KCNIP4).
                           "--alignMatesGapMax 1000000", # max gap between pair mates. As per ENCODE options.
                           "--alignSJoverhangMin 8 ", # minimum unannotated split read anchor. As per ENCODE options.
                           "--alignSJDBoverhangMin 3 ", # minimum annotated split read anchor. Default is 3.
                           "--limitSjdbInsertNsj ", format(limitSjdb, scientific=F) # maximum number of junction to be inserted to the genome on the ï¬‚y at the mapping stage, including those from annotations. Default is 1,000,000 -- but may need to be larger depending on annotation file.
    ))


  } else{

    # Just contains additional --outSAMattrRGline flag
    system(command = str_c("STAR",
                           " --runThreadN ", threads_STAR,
                           " --genomeDir ", genome_index_path,
                           " --sjdbFileChrStartEnd ", sj_path,
                           " --readFilesIn ", fastq_per_sample_paths_trimmed_paired[1], " ", fastq_per_sample_paths_trimmed_paired[2],
                           " --readFilesCommand  zcat ", # because fastq's are zipped
                           "--outFileNamePrefix ",  str_c(output_path, "/", sample_name_to_filter, "_ "),
                           "--outReadsUnmapped Fastx ", # output in separate fast/fastq files the unmapped/partially-mapped reads
                           "--outSAMtype BAM SortedByCoordinate ", # output as a sorted BAM
                           "--outSAMattrRGline ", str_c("ID:", read_group$full_name, " PU:", read_group$PU, " SM:", read_group$sample_name, " PL:Illumina LB:xxx "), # SAM/BAM read group line
                           "--outFilterType BySJout ", # removes spurious split reads
                           "--outFilterMultimapNmax 1 ", # only allows reads to be mapped to one position in the genome
                           "--outFilterMismatchNmax 999 ", # Maximum number of mismatches per pair. Large numbers switch off filter. Instead we filter by "--outFilterMismatchNoverReadLmax".
                           "--outFilterMismatchNoverReadLmax 0.04 ", # max number of mismatches per pair relative to read length. As per current ENCODE options.
                           "--alignIntronMin 20 ", # min intron length. As per ENCODE options.
                           "--alignIntronMax 1000000 ", # max intron length. As per ENCODE options (currently from ensembl its 1,097,903 from KCNIP4).
                           "--alignMatesGapMax 1000000", # max gap between pair mates. As per ENCODE options.
                           "--alignSJoverhangMin 8 ", # minimum unannotated split read anchor. As per ENCODE options.
                           "--alignSJDBoverhangMin 3 ", # minimum annotated split read anchor. Default is 3.
                           "--limitSjdbInsertNsj ", format(limitSjdb, scientific=F) # maximum number of junction to be inserted to the genome on the ï¬‚y at the mapping stage, including those from annotations. Default is 1,000,000 -- but may need to be larger depending on annotation file.

    ))


  }


}

